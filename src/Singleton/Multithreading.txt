Dealing with multithreading

Our multithreading woes are almost trivially fixed by making getInstance() a synchronized method:

public static synchronized Singleton getInstance() {

	if (uniqueInstance == null) {
		uniqueInstance = new Singleton();
	}

	return uniqueInstance;
}

I agree this fixes the problem. But synchronization is expensive; is this an issue?

Good point, and it’s actually a little worse than you make out: the only 
time synchronization is relevant is the first time through this method.
In other words, once we’ve set the uniqueInstance variable to an instance 
of Singleton, we have no further need to synchronize this method.
After the first time through, synchronization is totally unneeded overhead!

--------------------------------------------------------------------------------

Can we improve multithreading?

For most Java applications, we obviously need to ensure that the Singleton works in the presence 
of multiple threads. But, it looks fairly expensive to synchronize the getInstance() method, so what do we do?
Well, we have a few options...

1. Do nothing if the performance of getInstance() isn’t critical to your application 
That’s right; if calling the getInstance() method isn’t causing substantial overhead for your 
application, forget about it. Synchronizing getInstance() is straightforward and effective. Just keep 
in mind that synchronizing a method can decrease performance by a factor of 100, so if a high 
traffic part of your code begins using getInstance(), you may have to reconsider.

2. Move to an eagerly created instance rather than a lazily 
created one If your application always creates and uses an instance of the Singleton or the overhead of 
creation and runtime aspects of the Singleton are not onerous, you may want to create your 
Singleton eagerly, like this:

public class Singleton {

	// Go ahead and create an instance of Singleton in a static initializer. This code is guaranteed to be thread safe!
	private static Singleton uniqueInstance = new Singleton();

	private Singleton() {}

	public static Singleton getInstance() { return uniqueInstance; }
}

Using this approach, we rely on the JVM to create the unique instance of the Singleton when 
the class is loaded. The JVM guarantees that the instance will be created before any thread 
accesses the static uniqueInstance variable.

3. Use “double-checked locking” to reduce the use of synchronization in getInstance()
With double-checked locking, we first check to see if an instance is created, and if not, THEN we 
synchronize. This way, we only synchronize the first time through, just what we want.

public class Singleton {

	// The volatile keyword ensures that multiple threads handle the uniqueInstance variable correctly when it is being initialized to the Singleton instance.
	private volatile static Singleton uniqueInstance;

	private Singleton() {}

	public static Singleton getInstance() {

		// Check for an instance and if there isn’t one, enter a synchronized block.
		if (uniqueInstance == null) {
			synchronized (Singleton.class) {
				// Once in the block, check again and if still null, create an instance. It must be checked again, because another thread might have instatiated the class in between the IFs.
				if (uniqueInstance == null) {
					uniqueInstance = new Singleton();
				}
			}
		}

		return uniqueInstance;
	}
}

What about class loaders?
I heard there is a chance that two class loaders could each end up with their own instance of Singleton.
Yes, that is true as each class loader defines a namespace.
If you have two or more classloaders, you can load the same class multiple times 
(once in each classloader). Now, if that class happens to be a Singleton,
then since we have more than one version of the class, we also have more than 
one instance of the Singleton. So, if you are using multiple classloaders 
and Singletons, be careful. One way around this problem is to specify the classloader yourself.

Be careful if you are using multiple class loaders;
this could defeat the Singleton implementation and result in multiple instances.
